### Паттерн проектирования.

Это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
Паттерн не является готовым решением и не представляет собой готовый код.
Паттерн описывает общую концепцию, схему по которой можно выстроить взаимодействие между объектами для решения той или иной проблемы.

При изучении паттерна необходимо будет обратить внимание на следующие пункты:
1. проблема, которую решает паттерн (например, необходимость гарантии, что у класса есть только один экземпляр с глобальной точкой доступа);
2. структура классов, составляющих решение;
3. особенности реализации в различных контекстах (например, многопоточная среда);
4. взаимодействие данного паттерна с другими.

Группы паттернов:
1. Порождающие паттерны решают проблемы создания объектов.
    1. **Одиночка** (Singleton) гарантирует, что у класса есть только один экземпляр, предоставляет к нему глобальную точку доступа.
    2. **Прототип** (Clone, Prototype) описывает логику копирования объектов (возможно создание объектов с улучшенными характеристиками).
    3. **Строитель** (Builder) позволяет создавать сложные объекты, дает большую гибкость, чем конструкторы.
    4. **Фабричный метод** (Factory Method) логика по созданию объектов одного типа выносится в отдельный метод.
    5. Абстрактная фабрика (Abstract Factory) позволяет создавать семейства связанных объектов.
2. Структурные паттерны определяют взаимоотношения между классами и объектами.
    1. **Декоратор** (Decorator) позволяет добавлять объектам новую функциональность.
    2. **Компоновщик** (Composite) позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как с единым объектом.
    3. Адаптер (Adapter) позволяет объектам с несовместимыми интерфейсами работать вместе.
    4. Фасад (Facade) определяет одну точку взаимодействия с подсистемой.
    5. Мост (Bridge) позволяет разделить абстракцию и реализацию для их независимых изменений. 
3. Поведенческие паттерны определяют способы взаимодействия между сущностями.
    1. **Наблюдатель** (Observer) создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
    2. **Цепочка обязанностей** (Chain of Responsibility) позволяет передавать запросы (действия) последовательно по цепочке обработчиков.
    3. Итератор (Iterator) даёт возможность последовательно обходить элементы составных объектов.
    4. **Стратегия** (Strategy) инкапсулирует схожие действия в отдельные объекты и позволяет взаимозаменять их во время выполнения программы.
    5. _Команда_ (Command) инкапсулирует действия в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь,
       сохранять их последовательность, а также поддерживать отмену операций.
   6. 